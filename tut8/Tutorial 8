Student Names:
Joseph Robertson, Shomari Simpson
Conceptual Questions
1.What is an Abstract Data Type (ADT)?
An abstract data type is a mathematical model for a certain class of data structures that have similar behavior.
2.Explain the difference between a queue (FIFO) and a stack (LIFO).
In a queue, the oldest items are served first and in a stack, the newest items are served first.
3.Name and briefly explain three types of data structures.
Array: a collection of elements, each identified by at least one array index
Linked List: a linear collection of elements in which order is preserved with pointers that are associated with the element next in the sequence.
Class: objects that contain initial starting states and implementations of behaviors that can be instantiated individually.
4.Explain what a binary tree is, what are some common operations of a binary tree?
A binary tree is a data structure in which each node has at most two children.
Operations:create new node, remove node, search
5.Explain what a hash table (dictionary) is, what are common operations of a hash table?
A hash table is a data structure which implements a structure that can map keys to values.
Operation:insertion deletion, lookup
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>

#include <string.h>

struct proc{
    char parent[256];
    char name[256];
    int priority;
    int memory;
};

struct proc_tree{
    struct proc self;
    struct proc_tree * right;
    struct proc_tree * left;
};
struct proc_tree base;
struct proc_tree head;
struct proc_tree insert(struct proc process, struct proc_tree baseReference)
{
    //struct proc_tree * A = (struct proc_tree *)malloc(sizeof(struct proc_tree));
    //*A=baseReference;
    printf("refparent:%s\n",baseReference.self.parent);
    printf("refname:%s\n",baseReference.self.name);
    printf("processparent:%s\n",process.parent);
    printf("processname:%s\n",process.name);
    if (strcmp(process.parent,"NULL")==0){
        baseReference.self=process;
        baseReference.left = (struct proc_tree *)malloc(sizeof(struct proc_tree));
        baseReference.right = (struct proc_tree *)malloc(sizeof(struct proc_tree));
        strcpy((*baseReference.left).self.name,"NULL");
        strcpy((*baseReference.right).self.name,"NULL");
        printf("insert self\n");
        base=baseReference;
        head=baseReference;
        //return base;
        return baseReference;
    }
    if(strcmp (process.parent,baseReference.self.name)==0){
        if((strcmp ((*baseReference.left).self.name,"NULL"))==0){
            (*baseReference.left).left = (struct proc_tree *)malloc(sizeof(struct proc_tree));
            (*baseReference.left).right = (struct proc_tree *)malloc(sizeof(struct proc_tree));
            strcpy((*(*baseReference.left).left).self.name,"NULL");
            strcpy((*(*baseReference.left).right).self.name,"NULL");
            strcpy((*(*baseReference.left).left).self.name,process.parent);
            strcpy((*(*baseReference.left).right).self.name,process.parent);

            (*baseReference.left).self=process;
            (*baseReference.left).left=NULL;
            (*baseReference.left).right=NULL;
            //base=*A;
            //base=baseReference;
            printf("insert left\n");
            return baseReference;
            //return;
        }
        //if (baseReference.right==NULL){
        if((strcmp ((*baseReference.right).self.name,"NULL"))==0){
            (*baseReference.right).left = (struct proc_tree *)malloc(sizeof(struct proc_tree));
            (*baseReference.right).right = (struct proc_tree *)malloc(sizeof(struct proc_tree));
            strcpy((*(*baseReference.right).left).self.name,"NULL");
            strcpy((*(*baseReference.right).right).self.name,"NULL");
            strcpy((*(*baseReference.right).left).self.name,process.parent);
            strcpy((*(*baseReference.right).right).self.name,process.parent);
            
            (*baseReference.right).self=process;
            (*baseReference.right).left=NULL;
            (*baseReference.right).right=NULL;
            //base=*A;
            //base=baseReference;
            printf("insert right\n");
            return baseReference;
            //return;
        }
        else{
            printf("insert fail after parent-self match\n");
            return baseReference;
            //return;
        }
    }
    if((strcmp ((*baseReference.left).self.name,"NULL"))!=0){
        printf("checking left\n");
        (*baseReference.left).left = (struct proc_tree *)malloc(sizeof(struct proc_tree));
            (*baseReference.left).right = (struct proc_tree *)malloc(sizeof(struct proc_tree));
            strcpy((*(*baseReference.left).left).self.name,"NULL");
            strcpy((*(*baseReference.left).right).self.name,"NULL");
            strcpy((*(*baseReference.left).left).self.name,"NULL");
            strcpy((*(*baseReference.left).right).self.name,"NULL");
        //(*baseReference.left)=insert(process,(*baseReference.left));
        insert(process,(*baseReference.left));
        //return;
        //return baseReference;
    }
    if((strcmp ((*baseReference.right).self.name,"NULL"))!=0){
        printf("checking right\n");
        (*baseReference.right).left = (struct proc_tree *)malloc(sizeof(struct proc_tree));
            (*baseReference.right).right = (struct proc_tree *)malloc(sizeof(struct proc_tree));
            strcpy((*(*baseReference.right).left).self.name,"NULL");
            strcpy((*(*baseReference.right).right).self.name,"NULL");
            strcpy((*(*baseReference.right).left).self.name,"NULL");
            strcpy((*(*baseReference.right).right).self.name,"NULL");
        //(*baseReference.right)=insert(process,(*baseReference.right));
        insert(process,(*baseReference.right));
        //return;
        //return baseReference;
    }
    //printf("insert fail\n");
    //return baseReference;    
}

int print(struct proc_tree baseReference){
    printf("parent%s\n",baseReference.self.parent);
    printf("child%s\n",baseReference.self.name);
    printf("\n");

    if((baseReference).left!=NULL){
        if((baseReference).right!=NULL){
            return print(*baseReference.left) +print(*baseReference.right);
        }
        return print(*baseReference.left);
    }
    if((baseReference).right!=NULL){
            return print(*baseReference.right);    
    }
    printf("--end of branch--\n");
    return 0;
}
int main(){
    char name [256];
    char parent [256];
    int priority;
    int memory;
    strcpy((base).self.parent,"NULL");
    int size=7;
    freopen("processes_tree.txt","r",stdin);
    for(int x=0;x<size;x++){
        scanf("%s,",parent);
        scanf("%s,",name);
        scanf("%i,",&priority);
        scanf("%i,",&memory);
        //printf("%s",parent);
        struct proc process;
        strcpy(process.parent,strtok(parent,","));
        strcpy(process.name,strtok(name,","));
        process.priority=priority;
        process.memory=memory;
        insert(process,head);
        printf("\n");
    }
    
    print(base);
}
QUESTION 2:

#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <string.h>
#define MEMORY 1024

struct proc{
	char name[256];
	int priority;
	int pid;
	int address;
    int memory;
	int runtime;
	int suspended;
};
struct priority{
    struct proc process;
    struct priority * next;
};
struct secondary{
    struct proc process;
    struct secondary * next;
};
struct priority p;
struct secondary s;
void Ppush(struct proc process){
    struct priority * A = (struct priority *)malloc(sizeof(struct priority));
    (*A).process = process;
    (*A).next=p.next;
    p.next=A;
}
void Spush(struct proc process){
    struct secondary * A = (struct secondary *)malloc(sizeof(struct secondary));
    (*A).process = process;
    (*A).next=s.next;
    s.next=A;
}
struct proc Ppop(){
	struct proc r;
	r = p.process;
	p.next=(*p.next).next;
	p.process=(*p.next).process;
	return r;
}
struct proc Spop(){
	struct proc r;
	r = s.process;
	s.next=(*s.next).next;
	s.process=(*s.next).process;
	return r;
}
/*void print(struct queue * thisOne){
    if((*thisOne).next!=NULL){
        print((*thisOne).next);
    }
    printf("%s\t%i\t%i\t%i\n",(*thisOne).process.name,(*thisOne).process.priority,(*thisOne).process.pid,(*thisOne).process.runtime);
}*/

/*struct proc delete_name(char *name){
	struct queue * removedQueue = (struct queue *)malloc(sizeof(struct queue));
	struct queue * prev = (struct queue *)malloc(sizeof(struct queue));
	struct proc removedProcess;
	struct proc x;
	x.pid=0;
	*removedQueue =base;
	*prev =base;
	for(int x=0;x<sizeof(*removedQueue);x++){
		if (strcmp((*removedQueue).process.name,name)==0){
			removedProcess=(*removedQueue).process;
			(*removedQueue).next=(*prev).next;
			(*removedQueue).process=(*prev).process;
			printf("success\n");
			return removedProcess;
		}
		prev=(removedQueue);
		removedQueue=(*removedQueue).next;
	}
				printf("fail\n");
	return x;
}*/
/*struct proc delete_pid(int pid){
	struct queue * A = (struct queue *)malloc(sizeof(struct queue));
	struct proc r;
	struct proc x;
	x.pid=0;
	*A =base;
	while((*A).next!=NULL){
		if ((*A).process.pid==pid){
			r=(*A).process;
			(*A).next=(*((*A).next)).next;
			(*A).process=(*((*A).next)).process;
			printf("success\n");
			return r;
		}
		A=(*A).next;
	}
	return x;
}*/
int markMemInd(int avail_mem[MEMORY],int memory){
	int count;
	for (int x = 0; x < MEMORY; x++){
		if (avail_mem[x]==0){
			avail_mem[x]=1;
			count++;
		}
		if (count==memory){
			return x;
		}
	}
}
int checkMemInd(int avail_mem[MEMORY],int memory){
	int count;
	for (int x = 0; x < MEMORY; x++){
		if (avail_mem[x]==0){
			//avail_mem[x]=1;
			count++;
		}
		if (count==memory){
			return 1;
		}
	}
	return 0;
}
void freeMemInd(int memory,int avail_mem[MEMORY]){
			int count;
	for (int x = 0; x < MEMORY; x++){
		if (avail_mem[x]==1){
			avail_mem[x]=0;
			count++;
		}
		if (count==memory){
			return;
		}
	}
}
int main(){
	int avail_mem[MEMORY]={0};
		
	char aList[10][256],bList[10][256];
	for (int x = 0; x < 10; x++)
    	strcpy(aList[x], "");
	for (int x = 0; x < 10; x++)
    	strcpy(bList[x], "");

	int aCount=0,bCount=0;
    char name [256];
    int priority;
	int memory;
    int runtime;
    int size=10;
    freopen("processes_q5.txt","r",stdin);
    for(int x=0;x<size;x++){
        scanf("%s,",name);
        scanf("%i,",&priority);
		scanf("%i,",&memory);
        scanf("%i",&runtime);
        struct proc process;
        strcpy(process.name,strtok(name,","));
        process.priority=priority;
        process.memory=memory;
        process.runtime=runtime;

		if (priority==0){
			Ppush(process);
			//strcpy(aList[aCount],process.name);
			aCount++;
		}
		else{
			Spush(process);
			//strcpy(bList[bCount],process.name);
			bCount++;
		}
	
    }
    printf("done pushing\n");
	struct proc n;
	n=Ppop();
	int f= markMemInd(avail_mem,n.memory);
	while(n.name!=NULL){
		int status;
		int run = n.runtime;	
		n.address= f;
		printf("%s\t%i\t%i\t%i\n",n.name,n.priority,n.pid,n.runtime);
  		pid_t pid;
		pid = fork();
    	if (pid==0){
			printf("Hello from child!\n"); 
			execl("/home/dafungajunga/Documents/ostut8/process","process",NULL);
		    perror("execl() failure!\n\n");
		}
    	else{ 
			sleep(run);
			n.pid=pid;
			printf("Hello from Parent! %d\n",pid); 
			kill(pid,SIGINT);
			waitpid (pid, &status, 0);
			//printf("%s\t%i\t%i\t%i\n",n.name,n.priority,n.pid,n.runtime);
			freeMemInd(n.memory,avail_mem);
			n=Ppop();
			markMemInd(avail_mem,n.memory);
		}
	}

	n=Spop();
	n.pid=0;
	while(checkMemInd(avail_mem,n.memory)==0);
	f= markMemInd(avail_mem,n.memory);
	while(n.name!=NULL){
		int status;
		int run = n.runtime;	
		n.address=f;
		printf("%s\t%i\t%i\t%i\n",n.name,n.priority,n.pid,n.runtime);
  		pid_t pid;
		pid = fork();
    	if (pid==0){
			printf("Hello from child!\n"); 
			execl("/home/dafungajunga/Documents/ostut8/process","process",NULL);
		    perror("execl() failure!\n\n");
		}
    	else{
			n.pid=pid;
			if (n.suspended==1 && n.pid!=0 && n.runtime!=0){
				n.suspended==0;
				while(checkMemInd(avail_mem,n.memory)==0);
				markMemInd(avail_mem,n.memory);
				n.pid=pid;
				printf("Hello from Parent! %d\n",pid); 
				kill(pid,SIGCONT);
				sleep(1);
				n.pid=pid;
				n.runtime-=1;
				kill(pid,SIGSTOP);
				waitpid (pid, &status, 0);
				freeMemInd(n.memory,avail_mem);
				n.suspended==1;
				Spush(n);
				//n=Spop();
				//n.pid=0;
				
			}

			if (run==1){
			sleep(run);
			n.pid=pid;
			printf("Hello from Parent! %d\n",pid); 
			kill(pid,SIGINT);
			waitpid (pid, &status, 0);
			//printf("%s\t%i\t%i\t%i\n",n.name,n.priority,n.pid,n.runtime);
			freeMemInd(n.memory,avail_mem);
			}
			n=Spop();
			markMemInd(avail_mem,n.memory);
			while(checkMemInd(avail_mem,n.memory)==0);
			f= markMemInd(avail_mem,n.memory);
		}
	}
}


